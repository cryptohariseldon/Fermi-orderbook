import * as anchor from '@project-serum/anchor';
import * as spl from '@solana/spl-token';
import { assert } from 'chai';
import { IDL } from '../../target/types/fermi_dex';
const fs = require('fs');
import {createMint, createAssociatedTokenAccount, mintTo} from "./utils/utils"

const {Keypair,Connection} = require("@solana/web3.js");
const secretKey = JSON.parse(fs.readFileSync("/Users/zero/.config/solana/id.json"));


// Setup provider
const keypair = Keypair.fromSecretKey(new Uint8Array(secretKey));
const authority = keypair;
const wallet = new anchor.Wallet(authority);
const connection = new Connection("http://127.0.0.1:8899")
const provider = new anchor.AnchorProvider(connection,wallet,anchor.AnchorProvider.defaultOptions())

describe('fermi-dex-init', () => {
<<<<<<< HEAD:tests/sdk/3_initialize_new_market.ts
let programId = "DX5fj2BMuLwWEvJgrB2Z4JHsCWPDkB3c4Ev8aatrK6d2"
=======
let programId = "Htx8mCBRUF18a9wgAr7DQE16CUXejthVXasdQYRtRTKe"
>>>>>>> origin/approval1:tests/sdk/utils/3_initialize_new_market.ts

const program = new anchor.Program(IDL, programId, provider) //for existing prog
const coinMint = anchor.web3.Keypair.generate();
const pcMint = anchor.web3.Keypair.generate();

let coinVault: anchor.web3.PublicKey;
let pcVault: anchor.web3.PublicKey;

let marketPda: anchor.web3.PublicKey;
let marketPdaBump: number;

let bidsPda: anchor.web3.PublicKey;
let bidsPdaBump: number;
let asksPda: anchor.web3.PublicKey;
let asksPdaBump: number;

let reqQPda: anchor.web3.PublicKey;
let reqQPdaBump: number;

let eventQPda: anchor.web3.PublicKey;
let eventQPdaBump: number;

let openOrdersPda: anchor.web3.PublicKey;
let openOrdersPdaBump: number;


let openOrders_secondPda: anchor.web3.PublicKey;
let openOrders_secondPdaBump: number;

//const authority = anchor.web3.Keypair.generate();

before(async () => {
  /*
  await provider.connection.confirmTransaction(
    await provider.connection.requestAirdrop(
      authority.publicKey,
      2 * anchor.web3.LAMPORTS_PER_SOL,
    ),
  );
*/
//const provider = anchor.AnchorProvider.env();

  await createMint(provider, coinMint, 9);
  await createMint(provider, pcMint, 6);
  //program.programId = "HTbkjiBvVXMBWRFs4L56fSWaHpX343ZQGzY4htPQ5ver";
  [marketPda, marketPdaBump] = await anchor.web3.PublicKey.findProgramAddress(
    [
      Buffer.from('market', 'utf-8'),
      coinMint.publicKey.toBuffer(),
      pcMint.publicKey.toBuffer(),
    ],
    program.programId,
  );

  [bidsPda, bidsPdaBump] = await anchor.web3.PublicKey.findProgramAddress(
    [Buffer.from('bids', 'utf-8'), marketPda.toBuffer()],
    program.programId,
  );
  [asksPda, asksPdaBump] = await anchor.web3.PublicKey.findProgramAddress(
    [Buffer.from('asks', 'utf-8'), marketPda.toBuffer()],
    program.programId,
  );

  [reqQPda, reqQPdaBump] = await anchor.web3.PublicKey.findProgramAddress(
    [Buffer.from('req-q', 'utf-8'), marketPda.toBuffer()],
    program.programId,
  );
  [eventQPda, eventQPdaBump] = await anchor.web3.PublicKey.findProgramAddress(
    [Buffer.from('event-q', 'utf-8'), marketPda.toBuffer()],
    program.programId,
  );

  [openOrdersPda, openOrdersPdaBump] =
    await anchor.web3.PublicKey.findProgramAddress(
      [
        Buffer.from('open-orders', 'utf-8'),
        marketPda.toBuffer(),
        authority.publicKey.toBuffer(),
      ],
      program.programId,
    );

  coinVault = await spl.getAssociatedTokenAddress(
    coinMint.publicKey,
    marketPda,
    true,
  );
  pcVault = await spl.getAssociatedTokenAddress(
    pcMint.publicKey,
    marketPda, 
    true,
  );
});
console.log(marketPda);
console.log(pcVault);



  describe('#initialize_new_market', async () => {
    it('should initialize market successfully', async () => {
    //  const market = await program.account.market.fetch(marketPda);
      const constants = {
  programId: programId,
  marketPda: marketPda,
  coinVault: coinVault,
  pcVault: pcVault,
  coinMint: coinMint.publicKey,
  pcMint: pcMint.publicKey,
  bidsPda: bidsPda,
  asksPda: asksPda,
  reqQPda: reqQPda,
  eventQPda: eventQPda,
  authority: authority.publicKey,
}
const fileContentString = `// This file was generated by a script
${Object.entries(constants).map(([key, value]) => `export const ${key} = \"${value}\";`).join('\n')}
`;

const CONSTANTS_FILE_PATH = `./tests/sdk/utils/constants.ts`;

// write to file
fs.writeFile(CONSTANTS_FILE_PATH, fileContentString, (err) => {
  if (err) {
    console.error('Error writing to the file:', err);
  } else {
    console.log(`Constants file '${CONSTANTS_FILE_PATH}' generated successfully.`);
  }
});
      await program.methods
        .initializeMarket(new anchor.BN('1000000000'), new anchor.BN('1000000'))
        .accounts({
          market: marketPda,
          coinVault,
          pcVault,
          coinMint: coinMint.publicKey,
          pcMint: pcMint.publicKey,
          bids: bidsPda,
          asks: asksPda,
          reqQ: reqQPda,
          eventQ: eventQPda,
          authority: authority.publicKey,
        })
        .signers([authority])
        .rpc();
        console.log("Created market successfully")
      // const market = await program.account.market.fetch(marketPda);
      // assert(market.coinVault.equals(coinVault));
      // assert(market.pcVault.equals(pcVault));
      // assert(market.coinMint.equals(coinMint.publicKey));
      // assert(market.pcMint.equals(pcMint.publicKey));
      // assert(market.coinDepositsTotal.eq(new anchor.BN(0)));
      // assert(market.pcDepositsTotal.eq(new anchor.BN(0)));
      // assert(market.bids.equals(bidsPda));
      // assert(market.asks.equals(asksPda));
      // assert(market.reqQ.equals(reqQPda));
      // assert(market.eventQ.equals(eventQPda));
      // assert(market.authority.equals(authority.publicKey));
    });
  });
});