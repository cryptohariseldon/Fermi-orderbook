import * as anchor from '@project-serum/anchor';
import * as spl from '@solana/spl-token';

import { Keypair, Connection } from '@solana/web3.js';
import { createMint } from '../utils/createMint';
import fs from 'fs';
import { IDL } from '../../../target/types/fermi_dex';
import config from '../config';
import { getLocalKeypair } from '../utils/getLocalKeypair';

/**
 * Initializes a market on the Solana blockchain using the anchor framework.
 *
 * @param secretKeyPath - Path to the user's secret key.
 * @param programId - The string representation of the program ID for the dex.
 * @returns An object containing important market data.
 */
export async function initializeMarket(
  secretKeyPath: string,
  programId: string,
) {
  const keypair = getLocalKeypair(secretKeyPath)
  const authority = keypair;
  const wallet = new anchor.Wallet(authority);
  const connection = new Connection(config.rpcUrl);
  const provider = new anchor.AnchorProvider(
    connection,
    wallet,
    anchor.AnchorProvider.defaultOptions(),
  );

  const program = new anchor.Program(IDL, programId, provider);

  const coinMint = anchor.web3.Keypair.generate();
  const pcMint = anchor.web3.Keypair.generate();

  await createMint(provider, coinMint, 9);
  await createMint(provider, pcMint, 6);

  const [marketPda, marketPdaBump] =
    await anchor.web3.PublicKey.findProgramAddress(
      [
        Buffer.from('market', 'utf-8'),
        coinMint.publicKey.toBuffer(),
        pcMint.publicKey.toBuffer(),
      ],
      program.programId,
    );

  const [bidsPda, bidsPdaBump] = await anchor.web3.PublicKey.findProgramAddress(
    [Buffer.from('bids', 'utf-8'), marketPda.toBuffer()],
    program.programId,
  );
  const [asksPda, asksPdaBump] = await anchor.web3.PublicKey.findProgramAddress(
    [Buffer.from('asks', 'utf-8'), marketPda.toBuffer()],
    program.programId,
  );

  const [reqQPda, reqQPdaBump] = await anchor.web3.PublicKey.findProgramAddress(
    [Buffer.from('req-q', 'utf-8'), marketPda.toBuffer()],
    program.programId,
  );
  const [eventQPda, eventQPdaBump] =
    await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from('event-q', 'utf-8'), marketPda.toBuffer()],
      program.programId,
    );


  const coinVault = await spl.getAssociatedTokenAddress(
    coinMint.publicKey,
    marketPda,
    true,
  );
  const pcVault = await spl.getAssociatedTokenAddress(
    pcMint.publicKey,
    marketPda,
    true,
  );

  await program.methods
    .initializeMarket(new anchor.BN('1000000000'), new anchor.BN('1000000'))
    .accounts({
      market: marketPda,
      coinVault,
      pcVault,
      coinMint: coinMint.publicKey,
      pcMint: pcMint.publicKey,
      bids: bidsPda,
      asks: asksPda,
      reqQ: reqQPda,
      eventQ: eventQPda,
      authority: authority.publicKey,
    })
    .signers([authority])
    .rpc();

  const marketConstants = {
    programId: programId,
    marketPda: marketPda,
    coinVault: coinVault,
    pcVault: pcVault,
    coinMint: coinMint.publicKey,
    pcMint: pcMint.publicKey,
    bidsPda: bidsPda,
    asksPda: asksPda,
    reqQPda: reqQPda,
    eventQPda: eventQPda,
    authority: authority.publicKey,
  };

  const fileContentString = `// This file was generated by a script
  ${Object.entries(marketConstants)
  .map(([key, value]) => `export const ${key} = \"${value}\";`)
  .join('\n')}
`;

  const CONSTANTS_FILE_PATH = `./tests/src/constants.ts`;

  // write to file
  fs.writeFile(CONSTANTS_FILE_PATH, fileContentString, (err) => {
    if (err) {
      console.error('Error writing to the file:', err);
    } else {
      console.log(
        `Constants file '${CONSTANTS_FILE_PATH}' generated successfully.`,
      );
    }
  });
  return marketConstants;
}
